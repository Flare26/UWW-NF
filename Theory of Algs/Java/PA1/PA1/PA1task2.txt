Nathan Frazier
PA 1 Task 2

2.1:

Part 0 - This method creates a merge sort of the points using a custom comparator.
The comparator is passed to the MergeSort class, which parses and sorts the points according to if they have positive X or negative X value in relation to the given vertical axis.

Part 1 - After already being modified by part 0, this code tests if there's 3 or less X,Y pairs in the list.
If a pair has a Y value that is less than the Y value of the pair that comes before it, the pairs get swapped.
This is a custom version of insertion sort- it's modified to work with X,Y pairs.
Finally it calculates the distance of each pair ( brute force all points since there are not many ) and returns the minimum value.

Part 2 - If the list is longer, then the algorithm continues to work.
This part helps set up for divide and conquor by calculating the index of the mid pair, then stores the x value of the pair.

Part 3 - This part uses the mid that has just been found to take advantage of recursion.
All parts up to now will be repeated until the end condition from part 1 is met for the left and right sides of mid.

Part 4 - After the recursion has completed, the distances between the first two indexes of the left of mid list are compared, then repeated for the right and the results are both stored in their separate variables dLeft and dRight.
After this, a new variable dMin is declared, then dLeft and dRight are just compared against each other to see which is smaller. The lesser is assigned to Point [] closest.

Part 5 - Finds the lowest Y value points and merges them into their respective locations within the points array.

Part 6 - This part culls out all other points that do NOT satisfy the minimum distance requirement from xmid. All other points with distance > dMin are excluded.

Part 7 - Tests for the 2D distance between remaining points similar to the end condition of part 1, and returns the closest points in the form of a sorted array. 